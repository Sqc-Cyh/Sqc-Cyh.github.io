---

title: Note

hide:
  #  - navigation # 显示右
  #  - toc #显示左
  #  - footer
  #  - feedback  
comments: true  #默认不开启评论

---

<h1 id="欢迎">Note</h1>

## 1.基础知识
### 1.1 货币
* 货币的价值：
    1. 使用价值
    2. 交换价值

* 货币的形式：
    1. 贵金属：金、银、铜
    2. 纸币
    3. 数字货币

* 纸币的本质：信用
    1. 金本位
    2. 国家信用
    3. 布雷顿森林体系

* 纸币的全球化：    
    国际货币基金组织特别特别提款权：补充国际储备资产的不足，一开始相当于1美元，后背重新定义为一篮子货币

* 货币理论：
    1. 马克思政治经济学：商品的使用价值与交换价值
    2. 凯恩斯经济学：市场这只“看不见的手”有时候会失灵，需要政府干预
    3. 哈耶克经济学：自由市场、自由经营、自由竞争、自动 调节、自动均衡   
    货币非国有化
    4. 现代货币理论MMT：货币的本质就是欠条，即IOU(I Owe You)

??? tip "SWIFT环球银行间金融电讯协会"
    服务于金融业的全球通信网络，主要位金融机构提供跨境信息传送服务。
### 1.2 Hash算法
把任意长度的输入通过hash算法变换成固定长度的输出，该输出就是hash值。    

* hash算法的特征： 
    1. 输入空间任意，输出空间有限
    2. 可能发生碰撞
    3. 从输出不可能推导出输入  

* 最简单的hash算法  
    x mod y = z 整数取模运算、

* hash算法的应用：
    1. 快速定位（数据库中散列表）
    2. 错误校验
    3. 唯一性验证

* hash算法的安全性：
    1. 逆向困难，难以从输出推导出输入。
    MD、SHA算法都不可逆
    2. 抗碰撞：很难找到两个不同的输入，可以产生相同的输出。

* 安全哈希算法SHA256：
    输出为256位，输出空间是 $2^{256}$ 。目前尚未有破解方法

### 1.3加密算法

* 最简单的加密算法：凯撒密码

* 非对称加密算法

* 数字签名

## 2.区块链技术原理

* 数字货币面临的2个问题：
    1. 虚假货币：解决方案：数字签名（非对称加密技术）
    2. 多重支付：解决方案：分布式账本

### 2.1 概述：分布式账本技术原理    
将交易向全网所有节点进行广播    
➢众多记账节点对记账权达成共识，由共识确认的记账节点把记账区块发布给全网   
➢所有账本数据完整存储于区块链网络的每个节点  
➢所有节点都对账本数据的合法性和完整性进行验证

* 两个核心技术：   
    ➢以链式区块组织账本数据实现账本数据的不可篡改   
    ➢分布式的可信记账机制   

### 2.2 以链式区块组织账本数据实现账本数据的不可篡改（区块链的结构） 

#### 区块链的宏观结构
* 特点:
    1. 区块链中数据无法篡改或删除
    2. 区块链越长可信度越高

每一个区块保存了前一个区块的哈希值。   
![](./img/1.png){width="400"}

#### 区块的微观结构
每个区块包括区块头和交易数据两个部分
1. 区块头由当前区块的元数据和前一区块的Hash值构成
2. Merkle树用于对交易数据列表进行快速寻址

![](./img/2.png){width="400"}


* 区块的结构：  
![](./img/3.png){width="550"}

* 区块头的结构：   
![](./img/4.png){width="500"}

* 区块标识符：区块头哈希值和区块高度    
    1.**区块主标识符是它的加密哈希值**，一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹。
    
    >例如:000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f是第一个比特币区块的区块哈希值。

    2.区块哈希值实际上并不包含在区块的数据结构
    3.第二种识别区块的方式是通过该区块在区块链中的位置，即“区块高度（block height）”。
    
    >例如：高度为0的区块就是创世区块。

    4.和区块哈希值不同的是，区块高度并不是唯一的标识符，因为有可能出现区块链分叉。

* Merkle树:一种哈希二叉树(这种二叉树包含加密哈希值)。
    1. 叶节点是数据块的哈希值。
    2. 非叶节点的哈希值是根据它下面子节点的值哈希计算得到。
    
    在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。       

    Merkle树中使用两次SHA256算法计算结点的哈希值。
    
    ??? question "检查次数"   
        当N个数据元素经过加密后插入Merkle树时，至多计算 $log_2(N)$ 次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。

    ![](./img/5.png){width="500"}   

    如果是奇数，就将叶子复制一份再做hash作为非叶子节点的值。

    ![](./img/6.png){width="300"}

    * 价值：
        1. 快速比较大量数据：当两个Merkle树的根哈希值相同时，说明所代表的的数据都相同。
        2. 快速定位修改：如果其中某个交易（数据）发生修改，从根向下可以快速定位被修改的数据。
        3. 快速验证其中数据：要验证某个交易（数据）是否在Merkle树中，只需要提供一条从该交易的叶节点开始的路径，经过hash计算比对后即可验证。

    若已知HK，只需要再获取4个节点的值就可以得到根节点。
    ![](./img/7.png){width="500"}
#### 比特币区块链中的节点
* 全节点 full client：    
    存储着整个区块链，承但对交易请求进行验证和执行，可以通过挖矿争取发布区块，还承担着应别的节点之请向其发送区块和相关交易信息的义务，同时也承担转发交易请求和区块的义务。   
    1. 矿工节点
    2. 非矿工节点
* 轻节点 light client：   
    1. 简单支付验证（SPV）节点:只存储区块头，不存储区块块体，仍可以对到来的交易请求进行验证。
    2. 钱包:一个连接区块链的应用软件(app)，记录与所有者有关的信息：区块链地址、私钥、账户余额、UTXO等，不存储账本。

!!! tip "SPV（钱包）验证过程"
    针对某个支付到自己比特币地址的交易建立布隆过滤器，限制只接收含有目标比特币地址的交易。    
    
    其他全节点探测到某个交易符合SPV节点设置的布隆过滤器条件时，以Merkleblock消息的形式发送该区块，Merkleblock消息包含区块头和一条连接目标交易与Merkle根的Merkle路径。

    * **交易的存在性验证**：SPV节点通过该Merkle路径找到跟该交易相关的区块，并验证对应区块中是否存在目标交易<font color = "red">（Merkle Path Proof）</font>。
    * **交易是否双化验证**：SPV节点检查这笔交易所在区块之后的区块个数，区块个数越多说明该区块被全网更多节点共识，一般来说，一笔交易所属区块之后的区块个数达到<font color = "red">6</font>个时，说明这笔交易是可信的。

十分高效，需要验证的哈希数量很少。    
![](./img/8.png){width="500"}



### 2.3 分布式的可信记账机制

* 共识机制：由谁记账      
    ![](./img/10.png){width="400"}   

    1. 目的：解决记账权
    2. 场景：开放系统，动态增减，海量节点
    3. 解决方案：工作量证明（proof of work）：高强度哈希计算
    (SHA256)进行算力竞争解决记账权，达成共识      
    ![](./img/9.png){width="450"}

    * 工作量证明PoW共识：
      1. 划定固定时间段（10分钟）
      2. 相同或相似输入数据（组装的区块）
      3. 算力竞争选出获胜节点，其它节点验证结果后不再发送消息
      4. 最长链原则，从短期共识扩展到长期共识
??? example "拜占庭将军问题（分布式一致性）"
    | **将军**      | **节点** |
    | ----------- | ----------- | 
    | 每个将军控制自己的军队  | 每个分布式节点独立运行      | 
    | 通过信使给其他将军传递消息   | 相互间可通过网络通信  | 
    |将军中可能有叛徒|可能存在恶意节点|
    |信使是可靠的，但可能被截获|信道是可靠的，但可能中断|


    * 拜占庭将军问题算法的目标：   
        1. 一致性：所有忠诚的将军按照相同的计划行动
        2. 正确性：少数叛徒不能导致忠诚将军采取错误的行动计划

* 时序模型：
    1. 同步：分布式节点进程执行时间有确定的上限
    2. 异步：进程执行时间没有上限
* 故障模型:  
    1. 崩溃故障
    2. 拜占庭故障：节点崩溃、联系不上、恶意行为
* 容错模型：
    1. 崩溃容错 CFT(Crash Fault Tolerance)：指系统能够在部分节点崩溃或失效的情况下继续正常工作。
    2. 拜占庭容错 BFT(Byzantine Fault Tolerance)：指系统能够在部分节点表现出不可靠或恶意行为（如发送错误信息或故意破坏系统）时仍然能够正常工作。

### 2.4 区块的生成和组装    
竞争胜出的节点创建区块并广播    
其他独立节点校验新区块   

* 区块链的组装和选择（根据父区块hash值查找父区块），有三种情况：
    1. 连接到主链上
    2. 分叉（备用链）
    3. 孤立区块

* 区块链分叉解决方案:
    1. 把当前同一个父区块下的若干有效子区块都记录，形成兄弟区块（产生分叉）
    2. 后续区块（第3代、第4代……）到达后，依次加在前序区块后，若没有其他竞争性区块，这一分支最长，成为主链。

* 挖矿：比特币的产生
    1. 挖矿节点必须有钱包功能:有自己的160位密码地址、私钥
    2. 打包生成区块时，区块中额外加一个交易coinbase(生成给自己的奖励)
        1. 生成一个UTXO，包含当前奖励数量的比特币(现在是6.25)
        2. 这个UTXO的招领地址是自己的地址
        3. 如果记账成功，这个coinbase交易就生效，否则不在链上。


!!! tip "共识记账机制小结"
    1. 每个全节点依据综合标准对每个交易进行独立验证    
    2. 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块       
    3. 每个节点独立地对新区块进行校验并组装进区块链     
    4. 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链


### 2.5 UTXO模型
不存于现实世界，现实世界中只有两种模型：纸币（现金）模型、账户模型。    
1. 纸币模型：每张纸对应不同的面额。       
2. 账户模型：账户下面的余额。
   

UTXO (Unspent Transaction Output)：未花费的交易输出

* 比特币中有两类交易：
    1. 常规交易，有交易输入（支付者地址和金额）、交易输出（收入者地址和金额）
    2. 挖矿交易（Coinbase），产生比特币，只有交易输出（挖矿者地址和金额）

每个地址的资金余额就是散布在账本中所有UTXO的总和，使用时把自己名下的UTXO作为交易输入，可能需要拼凑找零。
??? example "一个例子🌰"
    类似于古代的金银交易，金银时代中，有时候需要称量银子的重量来进行价值的确定，并进行拼凑找零。

    UTXO与金银不同的是，不存在于“你的口袋”中，而更像是“贴在墙上”，需要通过特定的密码来取下来。也就是说，比特币不存在于个人的地址中，而是都存在一个特定的地址。

![](./img/11.png){width="350"}

* 交易的数据结构：  
```c++
class CTransaction {} //一个交易请求或交易记录
const std::vector<CTxIn> vin //本Tx的输入UTXO序列，即资金来源。
const std::vector<CTxOut> vout //本Tx的输出UTXO序列，即资金去向。
const int32_t nVersion // CURRENT_VERSION=2
const uint32_t nLockTime //锁定时间，时间未到点之前本交易不入块

const uint256 hash //本Tx的Hash值，只存储在内存中，
//不作永久存储也不发送。
```

* CTxOut的结构：    
```c++
class CTxOut {}
CAmount nValue //本项输出即该UTXO所承载的（比特币）价值,以聪（中本聪）为计量单位
CScript scriptPubKey //招领脚本，虽然名为scriptPubKey，
//却未必只是以公钥为条件的脚本
```
![](./img/12.png){width="400"}


* CTxIn的结构:  
```c++
class CTxIn {}
COutPoint prevout //Previews Output。指向具体的资金来源，
//说明来自那一项交易的第几项输出，展开如下：
uint256 hash //资金来源所在Tx的Hash值，唯一地确定了一个Tx。
uint32_t n //本项资金来源是该Tx中的第几项输出。
CScript scriptSig //为认领该项资金而提供的“签名脚本”（认领脚本）。
uint32_t nSequence //具有特殊作用。
CScriptWitness scriptWitness; //见证脚本的数据，0x00表示无
```
![](./img/13.png){width="400"}

* Coinbase交易:  
    1. 每一区块的第一笔交易必须是 Coinbase 交易，也称为生成交易，由挖矿节点生成。
        1. 交易输入为0
        2. 产生的UTXO = 挖矿奖励（目前6.25BTC）+ 区块交易费用
        3. 区块交易费用 = 所有输入的UTXO - 所有输出的UTXO
    2. Coinbase 交易的 UTXO 具有特殊条件，即至少 100 个区块内它不能花费（用作输入）。防止分叉产生导致的各种各样的矛盾纠纷。


### 2.6 比特币虚拟机
比特币节点软件的一个模块   
堆栈结构，可以运行有限的指令

* 运行的程序：
    1. 认领脚本 scriptSig
    2. 招领脚本 scriptPubKey

指令集：能力有限，主要验证签名是否正确
>OP_CHECHSIG,OP_DUP,OP_HASH160,OP_EQUALVERIFY……


#### 招领脚本scriptPubKey
* P2PK(Pay to Public Key):付给公钥。付给给定256位公钥的主人。
* P2PKH(Pay to Public Key Hash):付给公钥的Hash值。这里所谓的Hash，是特指对于
256位公钥的160位Hash，也就是对方的“地址”。
* P2SH(Pay to Script Hash):付给脚本的Hash值。给定一个脚本的Hash值，付给能提供这个脚本的对象，所提供脚本的Hash值必须与给定的Hash值相同。这个脚本是收付双方预先约定的，是双方在“链外” 约定的。


* 需要多方签名并采用SegWitness脚本的支付，具体又有两种：
    1. P2WPKH(Pay to SegWitness Public Key Hash):付给SegWitness形式的多个公钥Hash值。
    2. P2WSH(Pay to SegWitness script Hash):付给SegWitness形式的脚本Hash值。



#### 支付通道

比特币交易需要在10分钟之后被验证，（甚至挖矿得到的钱需要100个区块之后才能到），因此在实际生活中，没法用来做现实的支付（延迟太高）。所以出现了“支付通道”，不需要在链上进行支付。   

* 支付通道：所有交易在链外进行，等到结束后再到链上确认
    1. 用于链外支付或其他交易
    2. 面向性能要求高、交易数量大等场景

    >第一个支付通道应用场景：阿根廷有线电视比特币付费，按秒计费，如果
    每秒计费交易上链，比特币区块链无法满足性能要求，也会面对海量交易压力。(每秒都要计算，计算量过大)

* 涉及的链上交易：
    1. 注资交易（Funding Transaction）
    2. 应承交易（Commitment Transaction）
    3. 决算交易（Settlement Transaction）
    4. 退款交易（Refund Transaction）

* 支付通道过程：
    1. Funding transaction，建立支付通道
        A、B双方建立一个2-of-2多签名的联合地址，由拟议中的付方发布一个交易将一笔钱打到这个地址中；但这是P2SH支付，即支付给能够正确提供清算脚本Hash值的收款方，因为是2-of-2就必须有双方的签名才能花，。这是后面链外支付的资金来源。

        * 1个付款方：单向通道;2个付款方：双向通道
  
    2. Commitment transaction
        A、B双方的链下交易，可以有很多个，不上链。每次支付的资金都来自同一个UTXO，每次交易的输出分成两部分，一是给收方的UTXO，其数值是付方至此为止承诺支付的总和，二是给付方自己的找零。
    3. Settlement transaction
        收款方把手中由付款方开具并签名的最后那个应承交易上签上自己的名并把它发送到比特币网上，从当初注资阶段生成的那个UTXO中把钱划给自己，同时把剩余的钱（如果还有的话）找还给付款方。这个操作也可以由付款方发起，因为收款方每次收到应承交易都会签上自己的名并发还给付款方。

* 闪电网络（ Lightning Network ）:是一种支付通道，除了支付通道上述交易外，还有：   
    1. 转存交易（Delivery Transaction），任何一方都可以从联合地址认领属于自己的资金，把它转到一个自己更方便花费的地址中。
    2. 可撤转存交易（Revocable Delivery Transaction），可以撤销。
    3. 补救交易（Breach Remedy），这是在对方违约情况下加以补救并使对方受惩罚的交易。


!!! tip "总结：区块链技术"
    区块链技术是一种以<font color = "red">非对称加密技术对交易进行数字签名</font>，通过<font color = "red">工作量证明等共识机制进行记账节点协调</font>，数据以<font color = "red">链式区块形式组织存储</font>的分布式账本技术。
    
    * 区块链支撑技术：
        1. 非对称加密与数字签名
        2. 哈希计算：SHA256算法
        3. 链式区块结构
        4. Merkle树
        5. 共识机制：
            1. 拜占庭将军问题（Byzantine Generals Problem）
            2. PoW,PoS,DPoS
            3. PBFT、Raft
    * 优点：    
        1. 去中心化：避免垄断，点对点交易，去代理
        2. 数据公开：无暗箱操作，平等性，开放生态体系
        3. 可信：数据永久可靠，记录可信
   
    * 比特币区块链的问题：
        1. 隐私问题：匿名地址如何监管
        2. 性能问题：
            1. 交易确认时间长
            2. 区块容量有限 
        3. 系统性风险：区块链分叉和51%攻击（某人或者某人组织掌握了51%个节点，就可以发起攻击）

        !!! tip "比特币分叉"
            * 硬分叉、软分叉：主要看协议变化的程度
                 1. 硬分叉：新协议不兼容老区块
                 2. 软分叉：新协议兼容老区块

            ![](./img/14.png){width="500"}



## 3.数字货币与区块链生态
比特币之后的数字货币与区块链发展    
![](./img/15.png){width="400"}


* 区块链形态:
    1. 无许可区块链 permissionless blockchain:用户无需许可即可加入区块链网络
    2. 许可区块链 permissioned blockchain:用户需经许可才能加入区块链网络
    3. 用户 <> 共识节点
    4. 无许可区块链不一定是公链

* 莱特币 Litecoin:
    1. 出块速度：2分半
    2. 货币总量：到2140年达到8,400万
    3. 工作量证明算法：scrypt

* 狗狗币 Dogecoin:   
    1. 出块速度：60秒
    2. 货币总量：到2015年达到100,000,000,000（1,000亿）
    3. 共识算法：scrypt


* Ethereum（以太坊）：    
    Ethereum（以太坊）是一个平台和一种编程语言，使开发人员能够建立和发布下一代分布式应用。Ethereum可以用来编程，分散，担保和交易任何事物：投票，域名，金融交易所，众筹，公司管理， 合同和大部分的协议，知识产权，还有得益于硬件集成的智能资产。


* 数字货币钱包：    
    1. “钱包”是指用于存储和管理用户密钥的容器，钱包里没有“钱”，钱包软件一般还控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签署交易。
    2. 全节点：Bitcoin Core
    3. SPV轻钱包，只维护与自己相关的区块链数据
    4. 中心化钱包（在线钱包），依赖自己的中心化服务器，如blockchain.info
    5. 硬件钱包、冷钱包

## 4.以太坊技术分析

