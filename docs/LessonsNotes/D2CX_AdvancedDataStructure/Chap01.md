---

title: Chap 1 | “AVL Trees, Splay Trees,and Amortized Analysis”

hide:
  #  - navigation # 显示右
  #  - toc #显示左
  #  - footer
  #  - feedback  
comments: true  #默认不开启评论

---

<h1 id="欢迎">Chap 1 | “AVL Trees, Splay Trees,and Amortized</h1>

!!! note "章节启示录"
    <!-- === "Tab 1" -->
        <!-- Markdown **content**. -->
    <!-- === "Tab 2"
        More Markdown **content**. -->
    本章节是ADS的第一章，第一节课就已经感受到这门课的不一般之处，许多内容需要课后花时间好好消化，仅仅依靠上课听讲是不够的（也可能是我听的不认真以及没什么算法基础的缘故🥺）。接下来进入正题！
## 1.AVL树

### 1.1定义
!!! note ""
    AVL树的定义其实可以这么理解：它是一个较为平衡的二叉搜索树。AVL树希望解决的问题是让搜索变得更加迅速 ***（Speed up searching (with insertion and deletion)）***。因为在二叉搜索树中，可能会出现1~N这样Tree Height为N的极端坏情况。
### 1.2性质
#### 1.2.1性质介绍
!!! note ""
    *  空二叉树是一个AVL树
    *  如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 $\lvert h(ls) - h(rs)\rvert≤1$，h 是其左右子树的高度  
    *  树的高度为$O(logn) $
    !!! note ""
        因此我们有了一个新的定义 **平衡因子**（The balance factor）$BF=h(ls) - h(rs)$。  
        在一个AVL树中，$BF=-1,0,1$
#### 1.2.2性质证明
在实现构造AVL树前，我们先来分析并证明为什么AVL树的高度一定是$O(logn)$。
!!! abstract "$TreeHeight=O(logn)$"
    我们记$n_h$是高度为$h$的AVL树所包含的最少节点数，那么这个树一定长成这个样子:  
    ![](./img/8.png){width="400"}
    !!! danger "注意"
        在讨论最少节点数时，A的左右子树的高度不可能相等，若相等的话，则应该为该高度的最多节点。
    因此我们容易得到如下的递推关系式：  
    $$
        n_h =
        \begin{cases}
            1  &(h=0)\\\\
            2  &(h=1)\\\\
            n_{h-1}+n_{h-2}+1 &(h>1)\\\\
        \end{cases}
    $$
    这个形式与我们学过的斐波那契数列极其相似。



### 1.3构建AVL树
在一般的情况下，我们希望在建树的过程中直接构造出AVL树，而不是先构造出二叉搜索树再将其转换为AVL树，因此，我们需要在每一次添加节点（Insert node）后，使得新形成的树成为AVL时。当然，在此次插入前，我们构建的树必然也已经是一个AVL树，可以看到，这是一个迭代的问题。  
  
在介绍如何构建AVL树前，我们需要首先知道两个概念。
!!! note ""
    * Trouble Maker:当一个新插入的节点使得这棵新树不再是AVL树时，我们称它为Trouble Maker.
    * Trouble Finder:当出现Trouble Maker时，不断地向上寻找，看看是第一个找到的BF值跳出-1，0，-1的是哪一位祖辈，那么称这个祖辈对应的节点为Trouble Finder.
当我们了解清楚一些前情提要后，接下来就可以进入本章节的正题了！

!!! abstract "实现方法：旋转(Rotation)"
    旋转这个名字取得很有意思，接下来我会用比较多的篇幅介绍四种旋转的方式，一开始我觉得每一种旋转理解起来都不太容易，或者说都仿佛要记忆一样，但实际上“旋转”只是我们做的一个操作的形象的代名词（正如计算机中其他很多专业的术语一样，他们喜欢找一个生活中形象的例子来帮助人们理解）。但你可以简单地理解为，为了实现我们构造AVL树的目标，我们按照一些前任发现的特定的步骤，而这些步骤只要满足构造出来的新树仍然是二叉搜索树即可。听起来会有点抽象，下面我会具体来谈谈。

#### 1.3.1**RR/LL旋转**

!!! tips "命名"
    * RR旋转的命名是因为：对于Trouble Finder来说，Trouble Maker在它的右孩子的右孩子上（或者右孩子的右孩子的子树上）。我们注意到：RR旋转实际上应该是向左旋转，即逆时针。
    * LL旋转的命名是因为：对于Trouble Finder来说，Trouble Maker在它的左孩子的左孩子上（或者左孩子的左孩子的子树上）。我们注意到：LL旋转实际上应该是向右旋转，即顺时针。     
    **因此，我们可以简单的记忆：右逆左顺。**
以RR旋转为例进行说明，LL旋转为其镜像。   
![](./img/4.png){width="200"}
![](./img/5.png){ width="200"}  
我们可以在脑海中想象一下，将左图整个逆时针旋转，然后为了仍然满足二叉搜索树成立的条件，我们需要将B的左子树BL移动到A的右侧。

#### 1.3.2**RL/LR旋转**
!!! tips "命名"
    * RL旋转的命名是因为：对于Trouble Finder来说，Trouble Maker在它的右孩子的左孩子上（或者右孩子的左孩子的子树上）。RL旋转实际上应该是**从下到上****先**向左旋转，**再**向右旋转。
    * LL旋转的命名是因为：对于Trouble Finder来说，Trouble Maker在它的左孩子的右孩子上（或者左孩子的右孩子的子树上）。LR旋转实际上应该是**从下到上****先**向右旋转，**再**向左旋转。   
以RL旋转为例进行说明，LR旋转为其镜像。  
![](./img/6.png){width="200"}
![](./img/7.png){ width="200"}  
两次旋转的变化在脑海中有点难以想象，但稍微动一下笔，先向左进行旋转（将以B为根节点的子树做一遍RR旋转），再向右进行旋转（将以A为根节点的子树做一遍LL旋转）我们需要将B的左子树BL移动到A的右侧。



    