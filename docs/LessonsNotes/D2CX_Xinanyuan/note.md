---

title: Note 

hide:
  #  - navigation # 显示右
  #  - toc #显示左
  #  - footer
  #  - feedback  
comments: true  #默认不开启评论

---
<h1 id="欢迎">Note</h1>

## IS 0 Introduction

* 超过 80% 的攻击来自内部人员（内部）

!!! quesiton "What is Insiders"
    * 对环境或系统的某些方面具有合法访问权限或关联的人员。  
    * 与外部入侵者相比，内部人员的机会和知识更多。
    * 内部人士通常有明确的动机（报复、经济利益、信息等）

* 中国历史上第一个密码是什么？  
  太公兵法
* 谁发明了中共的第一个密码  
  豪密
* 凯撒密码
  将每个字母替换为它**位移**3
  密钥个数：25
* 棍子密码（Scytale Cipher）
  密钥是棍子的直径/周长
* 隐写术  
  连城诀的取诗中的第几个字  
  水浒传的藏头诗 卢俊义反  
  写进头皮、蜡烛里、鸡蛋里、微点（microdot）与电影、培根密码  
* 密码学的演变
  信息隐藏≠加密
  >一般来说，密码学的主要目标是保密。历史上列出的保守秘密的方式是人类智慧的精髓。但是，密码学的真正科学化应该归功于克尔克霍夫原理的出现及其后来的发展。
    * 第一次演变：Kerckhoffs 原理 
    * 第二次演变：计算机 
    * 第三次演变：公钥密码 
    * 第四次演变：互联网？手机互联网

* 科托夫原则（kerckhoff principle）
  Kerckhoffs原理意味着密码学从史前时期演变到经典时期：
    * 增强安全性：假设任何不变的东西都会被披露 
    * 加密算法本身不能保密,需要公开 
    * 保密性只取决于密钥 
    * 它使密码机的大规模生产成为可能

* 电子计算机（Electronic Compute）
    * 计算机出现在二战中，为了破解 ENIGMA
    * 计算机加速加密和解密
    * 理论依据——香农的信息论： 《通信的数学理论》，1948年 和《保密系统的通信理论》，1949 年
    * 现代密码的出现：DES

* 公钥密码学（Public Key Cipher）  
    公钥密码使得交换大量秘密消息成为可能，而无需在发送方和接收方之间共享任何密钥。

*  互联网（: (Mobile) Internet? AI?）
    * 密码学内涵的扩展：  
        不仅是“秘密”，还有其他问题;  
    * 扩展密码学的扩展：  
        应用：军事领域->民用领域->人员领域 
        保护：简单的 PTP 协议 - >复杂的 PTP 协议 - >各种互联网协议和应用 - > 5G、区块链、物联网和人工智能 
    * 硬件和软件开发的挑战：   
         提升硬件性能和容量并降低成本;  
         海量分布式计算、云计算、密码分析等;

!!! abstract "computer VS paper"
    * 我们可以分辨纸质文档的原件和副本之间的区别。但是，对于数字文档，我们无法区分原件和副本。
    * 纸上的改动会留下物理痕迹。但是，数字纸上的改动不会留下任何东西。
    * 纸质文档相对难以销毁。但是，数字文档确实很容易删除。
    * 根据其物理特性验证手写签名和印章。但是，数字信息仅依赖于二进制信息。

* 计算机安全的特征  
    全面性（comprehensive）：一个系统安全取决于最弱的一环。  
    过程性（procedural）：不断来会上升的螺旋式上升安全模型。  
    动态性（dynamic）：整个安全系统处在不断的进步、更新过程。  
    层次性（hierarchy）：必须使用多层安全技术去解决安全风险。  
    相对性（relative）：安全是相对的，没有绝对安全。

!!! abstract "计算机安全的三元素（3 elements）"
    <font color='red'> 
    保密性（confidential）：别人能看到我们的数据吗  
    完整性（integrity）：我们的数据会被非法修改吗  
    可用性（available）：资源可用吗  
    真实性（authentic）：信息的来源真的是声明的来源吗</font>

* 计算机安全概念  
    资产(asset):人员、财产和信息。资产是我们试图保护的东西。  
    威胁（threats）：是否有可能造成损害的情况。    
    漏洞(vulnerability):安全程序中的弱点或漏洞，威胁可以利用这些漏洞或漏洞来获得对资产的未经授权的访问。漏洞是我们保护工作中的弱点或差距。  
    风险 （Risk）:由于利用漏洞的威胁而导致资产损失、损坏或破坏的可能性。风险是资产、威胁和漏洞的交集。

* 安全威胁类型：
    自然威胁：地震火灾洪水闪电
    物理威胁：错误使用、不小心损坏
    硬件/软件威胁：不合适的设计、后门、逻辑炸弹、系统冲突
    介质威胁：硬盘（HDD）损坏、不小心删除、不小心退磁
    泄露（leak）威胁：电磁泄露，屏幕监视
    通信威胁：抓包、通信过程中的修改和伪造
    个人威胁：不小心删除，故意破坏和泄露

!!! danger "安全攻击类型：" 
    中断（interrupt）、 截取（interception）、修改（modification）、伪装（fabrication）
    ![](./img/1.png)  

    * 中断： 
        硬件损坏、物理通信链损坏、引入噪音、删除例程、删除程序或文件、拒绝服务攻击（DOS）。
        * 攻击可用性
    * 截取：
        窃听、链路监控、数据包捕获、系统黑客攻击和破坏
        * 攻击保密性
    * 修改：
        修改数据库中的记录、系统黑客攻击、通信延迟、修改硬战。
        * 攻击完整性
    * 伪装：
        在数据库中插入记录、插入数据包（使用伪造的 IP 地址）、使用伪造的电子邮件或网址钓鱼。
        * 攻击真实性

    !!! danger "replay" 
        ![](./img/2.png)
* 对抗安全威胁的目标:   
    预防:防止攻击者违反安全策略。  
    检测:检测攻击者违反安全策略的行为。  
    恢复:攻击已停止，系统已修复，操作已恢复。  
        （高级版）即使攻击成功，也能继续正常工作。

* 对抗安全威胁的安全服务：
    * 身份验证:
        确保通信实体是它们声明的实体，包括对等实体身份验证和数据源身份验证。
    * 访问控制:
        防止未经授权访问资源 
    * 数据机密性:
        防止数据泄露，包括链接机密性、未链接机密性、选定字段机密性和流机密性。
    * 数据完整性: 
        确保接收到的数据是从授权实体发送的，并且无需修改即可插入、删除和重放。
    * 不可否认性:
        防止任何实体的通信中断。 
    * 可用性:
        确保服务的可用性。
* 对抗安全威胁三成靠技术七成靠管理，人的问题是迄今为止安全问题的主要来源。

## IS 1.1 Fundamentals of Cryptography

### 密码学基础
* 术语  
    明文（plaintext，P）   
    密文（ciphertext，C）  
    加密（encryption method，E（））   
    解密方法（Decryption，D（））  
    Key（key，K）  
    $C = E_K(P)$   
    $P = D_K(C)$

* 加密算法：  
    * 置换、替换：（Substitution）  
        Plaintext: A B C D E F G H I J K L M N O P R S T U V W X Y  
        Ciphertext: Q T U G N H Z M U R B S A O W I D Y E C P F K X
    * 位移：（Transposition）  
        Plaintext： 信息安全导论  
        Ciphertext： 信全息导论安

* 密码分析：
    * 攻击者可用的信息量：  
        仅密文：密码分析人员只能访问密文集合。  
        已知明文：攻击者拥有一组他知道相应明文的密文。  
        选择明文（chosen-ciphertext）：攻击者可以获取与他选择的任意一组明文（密文）相对应的密文（明文）。    
        自适应选择明文：与选择明文攻击类似，攻击者可以根据从先前加密中学到的信息选择后续明文。    
        相关密钥攻击：与选择明文攻击类似，但攻击者可以获取使用两个不同密钥加密的密文。    
        密钥未知，但它们的关系是已知的;例如，两个键在一个位上不同。
    * 攻击/分析的结果：  
        完全中断 ― 攻击者推断出密钥。  
        全局演绎 — 攻击者在不学习密钥的情况下发现了功能等效的加密和解密算法。  
        实例（本地）推导 — 攻击者发现以前未知的明文（或密文）。  
        信息推导 — 攻击者获得一些以前未知的有关明文（或密文）的香农信息。  
        区分算法 — 攻击者可以将密码与随机排列区分开来

### 密码学历史
古典密码：第一次世界大战之前、手工艺密码。  
机器密码：出现在第一次世界大战中、在第二次世界大战中广泛使用、机械或电子密码机。  
计算机密码：第二次世界大战后、计算机算法。 

* 古典密码：
    * 例子：  
        棍子密码、
        古希腊密码（二维密码表 字母->二维坐标）、
        凯撒密码、
        女皇玛丽密码 （字母->符号）
    * 破解：  
        频率分析法
    * 进阶：
        维吉尼亚密码（vigenere square）、书密码

    ![](./img/3.png)

    密钥是DEFCONDEFCON  
    明文对照密钥，通过右边的表转为密文

!!! example "破解Vigenere"
    找相同单词出现的间隔，然后对这些数取最大公约数，一般就是密钥的长度。然后根据密钥的长度（若为3），则每隔这么长（3）统计每个字母出现的次数，然后做频率分析。出现最多的一般为e，寻找对应密钥。 

    ![](./img/4.png)  
    ![](./img/5.png)

* 机械密码： 
    * 齿轮机：ENIGMA  
        加密算法：整个机器、物理结构、齿轮  
        密钥：齿轮的初始位置、齿轮的顺序、插板  

        ![](./img/6.png)

        密钥个数：  

        ![](./img/7.png)

        符合科托夫原则

    * 破解ENIGMA：
        Step1：间谍  
        Step2：误用  
        Step3：数学破解  

        数学方法：Marian Rejewski证明，link长度取决于齿轮的配置，但不取决于插板的配置。  
        Bombe机

    * ENIGMA带来的启示：  
    Enigma 是一种加密算法。  
    密钥是“转子的初始设置”和“插线板布置”。  
    被破解的原因：误用、“重复”导致“模式”、“插板布置”提供了最多的关键空间，但对许多攻击很弱。  
    破解加密算法的方法：搜索“模式”、降低“复杂性”/“维度”、 蛮力。  
    （当然，你需要一个强大的“数学背景”和一点“运气”）

* 计算机密码：    
    Symmetric key ciphers（对称密钥密码学）  
    Asymmetric key ciphers（非对称密钥密码学）

## IS 1.2  Symmetric key ciphers & Asymmetric key ciphers

### 对称密钥加密算法
又叫做共享密钥加密算法/保密密钥加密算法。  
对称密钥算法是密码学中的一种加密算法。     
对称密钥算法是加密算法，它使用相同的加密密钥进行明文加密和密文解密。  
密钥可能相同，或者两个密钥之间可能有简单的转换。实际上，密钥表示两方或多方之间的共享密钥，可用于维护私有信息链接。要求双方都有权访问密钥是对称密钥加密的主要缺点之一。  
符合Kerckhoffs原则。

* 块加密：  
将输入位流划分为 n 位段，并仅加密该段。段之间没有依赖关系/历史记录。  
在一个好的分组密码中，每个输出位都是所有 n 个输入位和所有 k 个密钥位的函数。
![](./img/8.png)

* 费斯托密码（Feistel Cipher）:  
    1973 年由 IBM Feistel 提出,几乎所有现代对称加密算法都基于这种结构。  
    使用块加密，并增加块大小。如果采用理想的块加密（完全随机映射）可能会导致密钥长度过长 $(n*2^n)$，则 $n = 64$ 需要密钥的 $2^{70}$ 位长度。  
    因此，它需要近似于理想的分组密码。  
    设计：Feistel 利用乘积密码的概念来解决这个问题。
    用两种方法来引起雪崩效应：
     * 扩散:使得密文的统计特性与明文之间的关系尽量复杂。
     * 混淆/扰乱:使得密文的统计特性与加密密钥之间的关系尽量复杂

    !!! examlple "Feistel cipher encryption"
            
        ![](./img/9.png)

        * 扩散:迭代交换左半部分。
        * 扰乱：循环函数 F  
            块大小：块大小越大，安全性越高;典型大小为 64 位或 128 位。   
            密钥长度：密钥大小越大，安全性越高;典型大小为 128 位。  
            循环数：循环次数越多，安全性越高，标准大小为 16。  
            子密钥生成算法：该算法的复杂性越高，密码分析的难度就越大。   
            循环函数 F：复杂度越高，对密码分析的抵抗力越强

* DES算法：
    * 块大小 64bits，密钥长度 56bits
    * 特点：  
        强烈的雪崩效应  
        很强的反破解能力，只能爆破  
        目前 56bits 密钥太垃圾了  

        ![](./img/10.png)

        !!! example "Single Round of DES Algorithm"
            ![](./img/11.png)

    * 三重DES：  
        $C = E_{k3}[D_{k2}[E_{k1}[P]]]$  
        C为密文、P为明文。  
        用EDE的方式是因为当 $K1=K2/K2=K3$ 时，等价于DES算法，兼容旧设备。
        密钥长度：56*3=168  
        PGP 和 S/MIME 采用的算法

* AES算法：  
    替换 DES 和 三重DES 以克服三重DES的以下缺点：  
    三重DES在软件上实现缓慢   
    块大小仅为 64 位   
    * AES的特点：  
    块大小：128bits   
    密钥大小：128/192/256 位   
    免疫所有已知攻击    
    在每个平台上执行速度快，代码紧凑  
    设计简单  

* ECB：用于长数字序列的块密码
    ![](./img/12.png)  
    如果攻击者认为区块 C2 对应于 $ 金额，则替换另一个 Ck（仅密文攻击）攻击者还可以构建一个 <Ck、猜测的 Pk\>对（选择明文攻击）的密码本。
    question:重放攻击能攻击吗?

* CBC：  
    ![](./img/13.png)  
    抑制重放攻击和密码本构建：由于是基于内存的链接，相同的明文 $P_i = P_k$ 不会产生相同的输出代码。     
    IV = 初始化向量（仅使用一次）

* 两者的区别：  
    ![](./img/14.png)  
    ECB 对于同样的明文块会被加密成相同的密文块；因此，它不能很好的隐藏数据模式。   
    CBC 上一个块的结果会影响下一个块。

* 块加密之外：流加密（Stream Cipher）：  
    ![](./img/15.png)    
    ![](./img/16.png)  
    不像块密码那样将比特流划分为离散块，而是将明文连续流的每个比特与伪随机序列中的比特进行异或。再次使用相同的对称密钥 XOR 在接收器处提取明文。

* 密钥分发问题:    
    根据 Kerckhoffs 的原理，密钥是最重要的！  
    对于对称加密，密钥应该共享，那么应该如何共享密钥才能保证安全呢？   
    * 对于对称加密，密钥分配有以下几种方式：  
    1.A 可以选择一个密钥并将其物理交付给 B。  
    2.第三方选择密钥并将其物理返回给 A 和 B。   
    3.如果 A 和 B 以前和最近使用过密钥，一方可以将新密钥传输给另一方， 使用旧密钥加密。  
    4.如果 A 和 B 与第三方 C 有加密连接，则 C 可以在加密链接上向 A 和 B 提供密钥。典型解决方案—— 密钥分发中心（KDC）。  
    **这能保证机密性吗**？

### 公钥密码学
* 密钥加密的问题： 
   
    >Alice 通过电子邮件向 Bob 发送了一篇未发表的论文:  
    问题 1：Alice 不希望除了 Bob 之外的其他人阅读她的论文 Alice 需要加密她的论文，但她如何告诉 Bob 密码？  
    如果她通过电子邮件发送密码，任何捕获 Alice 和 Bob 之间所有电子邮件的人都可以阅读未发表的论文。  
    问题 2：如果 Bob 剽窃并发表了论文，Alice 应该能够证明 Bob 的剽窃吗？

!!! abstract "公钥密码学"  
    ![](./img/17.png) 

    * 六要素：明文、公钥 KU 、私钥 KR 、加密算法 、密文 、解密算法
    * 一个成功的公钥系统的关键是找到一个单向函数（计算函数的结果很容易，但逆向计算是不可行的）
    * 公钥密码学的要求：
        * B方在计算上很容易生成一对（公钥$KU_b$，私钥$KR_b$）。  
            确保：密钥生成简单。
        * 发送方 A 在计算上很容易加密。  
            确保：及时加密是可以接受的。 
        * 接收方 B 在计算上很容易解密  
            确保：及时解密是可以接受的。 
        * 对于知道公钥 $KU_b$ 的攻击者来说，确定私钥 $KR_b$ 在计算上是不可行的。 
        * 仅知道公钥 $KU_b$ 和密文 $C$ ，攻击者在计算上仍然无法恢复原始消息 $M$ 。 
        * 可以交换密码对。
            确保：既可用于加密，也可用于签名。

* DH算法:  
    ![](./img/18.png)  
    g 是 p 的原根（primitive root），a 叫做 A 的离散对数，**是唯一的**。  
    $\large A=g^a \;mod \;p$  
    * DH 算法寻找到的单向函数是，计算大整数的整数次幂求模是很容易的，但反向求出离散对数是十分难的。
    * a,b,p 的选择对于 DH 算法有很大的影响：  
        如果 p 很小的话，结果很容易爆破  
        一般我们用三百位的 p，一百位的 a 和 b  
        g 一般 2 3 5 都可以
    
    ![](./img/19.png)  
    Alice的密钥：a，Bob的密钥：b  
    Alice的公钥：A，Bob的公钥：B  
    共享的信息（公钥）：g，p  
    连接密钥：K  

    >e.g:  
    选择一个素数 p = 353，原根 g = 3   
    选择私钥：a = 97，b = 233    
    计算公钥：  
    $\large A = 3^{97} \;mod \;353 \;= \;40$   
    $\large B = 3^{233} \;mod \;353 \;= \;248$   
    每个交换的计算机密钥：   
    $\large A：K = B^a \;mod \;353 \;= \;(248)^{97} \;mod \;353 \;= \;160$    
    $\large B：K = A^b \;mod \;353 \;= \;(40)^{233} \;mod \;353 \;= \;160$

    * DH算法没有认证环节，很容易受到中间人攻击。
  
    ![](./img/20.png)

* RSA算法：  
    * 单向函数：大质数乘法很容易，但是大合数的质因子分解十分困难
    !!! abstract "RSA算法过程："
        * Step1:选择两个素数 p 和 q（至少 100 位），将 p 和 q相乘：$n = p * q$ 
        * Step2:找出两个数字 e 和 d，使得:
        e和(p-1)(q-1)互质，而且1 < e & d < (p-1)(q-1)  
        $\large e*d \equiv 1 \;(mod(p-1)(q-1))$<font color='red'>（应该是这步操作防范了中间人攻击）</font>
        * Step3:（e，n） 作为公钥，d 作为私钥。

        >e.g:  
        Alice 将明文 m（m 必须小于 n）加密到 c 并发送给 Bob：     
        首先，找到 Bob 的公钥 （e， n），并计算：$\large c = m^e \;mod \;n$    
        向 Bob 发送密码 c   
        Bob 接收密码 c，解密并获取明文 m  
        使用私钥 d 计算：$\large m = c^d \;mod \;n$

        ![](./img/21.png)

        !!! example "两个例子🌰"
            **例子1**：

            * Bob 选择两个素数 p = 5， q = 11， 求出 $n = p*q = 55$   
                （p-1）（q-1）= 4*10 = 40   
                求两个数字： e = 3， d = 27 和：3 * 27 ≡ 1 （mod 40）   
                Bob 的公钥是： （3， 55），私钥是：27 
            * Alice 向 Bob 发送消息 m = 13： 
                接收 Bob 的公钥 （3,55），并计算：  $\large c = m^e \;mod \;n \;= \;13^3 \;mod \;55 \;= \;2197 \;mod \;55 \;= \;52$   
                Alice向 Bob 发送密码 c = 52。
            * Bob 收到消息 c = 52： 
                使用私钥 27，计算：$\large m \;= \;c^d \;mod \;n \;= \;52^{27} \;mod \;55 \;= \;13$

            **例子2**：

            * Bob 选择两个素数 p = 101， q = 113， 求出 $n = p*q = 11413$   
                （p-1）（q-1）= 100*112 = 11200   
                求两个数字： e = 3533， d = 6597 和：3533 * 6597 ≡ 1 （mod 11200）   
                Bob 的公钥是： （3533， 11413），私钥是：6597 
            * Alice 向 Bob 发送消息 m = 9726： 
                接收 Bob 的公钥 （3533,11413），并计算：  
                $\large c = m^e \;mod \;n \;= \;9726^{3533} \;mod \;11413 \;= \;5761$   
                Alice向 Bob 发送密码 c = 5761。
            * Bob 收到消息 c = 7612： 
                使用私钥 6597，计算：$\large m \;= \;c^d \;mod \;n \;= \;5761^{6597} \;mod \;11413 \;= \;9726$  
    * RSA算法安全吗？  
        * 攻击者可以得到c和（e，n），想获得m有以下途径：  
            1.得到 B 的私钥 d 

            >B保护的很好！  

            2.m 是 1 到 n 的数字，爆破。  

            >但 n 太大（如前所述，p 和 q 通常是 100 位素数）

            3.尝试从（e，n）计算出私钥 d  
            已知$e*d\equiv 1 \;(mod \;(p-1)(q-1))$ 

            * 攻击者发现了一种称为“扩展 EUCLID 算法”的有效算法来解决以下问题：给定两个数字 （r， s），计算 x 使得：  
                $r*x \equiv 1 (mod s)$  
            
            一旦 n 可以分解为 p 和 q，就可以很容易地找到 d！
        
        攻击者在方法 3 中攻击所花费的时间基本上是分解的时间：  
        因此，我们说 RSA 基于因式分解问题：虽然将大素数相乘很容易，但将大复合分解或拆分为其素因数在计算上是不可行的！<font color='red'>单向性！</font>

        !!! warning "不死心的攻击者——第4种攻击方法！"
            * 攻击者冒充 B 告诉 A 自己的新公钥，此后攻击者就可以用自己的私钥解密了！
            * 在 A 发密文给 B 前，核对 B 的公钥对不对，A 必须确认拿到的是 B 的公钥，除了 B 没人能给 A 发验证。

* 对称密码学和非对称密码学的比较：  
    * 对称密码：  
    优点：便宜又快; 提供低成本VLSI芯片。  
    缺点：密钥分配是个问题！   
    * 非对称密码：   
    优点：密钥分发不是问题！  
    缺点：相对昂贵且速度慢;VLSI芯片不可用或相对昂贵。  
    * 在实践中：   
    使用公钥密码（如 RSA）分发密钥   
    使用私钥密码（如 AES）加密和解密消息  
    !!! warning "两个误解"
        * 公开密钥加密在防范密码攻击上比常规加密更安全。  
            实际上，两者都依赖于密钥长度和解密的计算工作量，从抗密码分析的角度分析，互相之间都不比对方优越。
        * 公开密钥加密使得常规加密过时。  
            实际上，公开密钥加密在计算上相对的巨大开销，使得公开密钥加密更多地用于密钥管理和数字签名应用。

