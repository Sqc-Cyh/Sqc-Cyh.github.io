---

title: Chap 3 | 数据链路层

hide:
  #  - navigation # 显示右
  #  - toc #显示左
  #  - footer
  #  - feedback  
comments: true  #默认不开启评论

---
<h1 id="欢迎">Chap 3 | 数据链路层</h1>
!!! note "章节启示录"
    <!-- === "Tab 1" -->
        <!-- Markdown **content**. -->
    <!-- === "Tab 2"
        More Markdown **content**. -->
    本章节是计算机网络的第三章。有些内容可能不重要，后续应该会标注。

## 1.数据链路层的设计问题
向下：利用物理层提供的位流服务    
向上：向网络层提供明确的 (well-defined) 服务接口

* 功能：
    1. 成帧 （Framing）：将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误，数据链路层功能需借助“帧”的各个域来实现
    2. 差错控制 （Error Control）：处理传输中出现的差错，如位错误、丢失等
    3. 流量控制 （Flow Control）[不做要求]：确保发送方的发送速率，不大于接收方的处理速率。避免接收缓冲区溢出

* 提供的服务：
    1. 无确认 无连接 服务(Unacknowledged connectionless)
        1. 接收方不对收到的帧进行确认
        2. 适用场景：误码率低的可靠信道；实时通信；
        3. 网络实例：以太网
    2. 有确认 无连接 服务(Acknowledged connectionless)
        1. 每一帧都得到单独的确认
        2. 适用场景：不可靠的信道（无线信道）
        3. 网络实例：802.11
    3. 有确认 有连接 服务(Acknowledged connection-oriented)   
        1. 适用场景：长延迟的不可靠信道

### 1.1 成帧(framing)
接收方必须能从物理层接收的比特流中明确区分出一帧的开始和结束，这个问题被称为帧同步或帧定界

关键：选择何种定界符？定界符出现在数据部分如何处理？     

* 成帧的方式：
    1. 字节计数法(Byte count)
    2. 带字节填充的定界符法(Flag bytes with byte stuffing)
    3. 带比特填充的定界符法(Flag bits with bit stuffing)
    4. 物理层编码违例(Physical layer coding violations)

* 字节计数法：无差错传输的情形    
    ![](./img/47.png)

    如果出现一处错误，后续都会错误，因此实际中基本没有被使用。

* 带字节填充的定界符法：   
    定界符（FLAG）：一个特殊的字节，比如 01111110，即 0x7E，用于区分前后两个不同的帧
    
    ![](./img/48.png){width="500"}

    * 发送方：检查有效载荷，进行字节填充 
        如果在数据中存在"FLAG"，需要在前面加一个转义字符，来进行区分。进而，如果数据中存在"ESC",则需要在前面再加一个转义字符

        ![](./img/49.png){width="500"}

    * 接收方的处理：
        1. 逐个检查收到的每一个字节
        2. 收到ESC：则后一字节无条件成为有效载荷，不予检查
        3. 收到FLAG：则为帧的边界

    * 问题：有什么不足？    
        Overhead 较大，不是数据本身的内容占据的太多

* 带比特填充的定界符法：    
    定界符：两个0比特之间，连续6个1比特，即01111110，0x7E

    * 发送方：检查有效载荷   
        若在有效载荷中出现连续5个1比特，则直接插入1个0比特,意味着数据中不会出现连续6个1，即不会出现定界符   
        ![](./img/50.png)
    
    * 接收方：