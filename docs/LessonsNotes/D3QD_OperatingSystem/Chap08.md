---

title: Chap 8 | Main Memory

hide:
  #  - navigation # 显示右
  #  - toc #显示左
  #  - footer
  #  - feedback  
comments: true  #默认不开启评论

---

<h1 id="欢迎">Chap 8 | Main Memory</h1>

!!! note "章节启示录"
    <!-- === "Tab 1" -->
        <!-- Markdown **content**. -->
    <!-- === "Tab 2"
        More Markdown **content**. -->
    本章节是OS的第八章。

## 1. Background
* 内存管理的主要功能：
    1. 内存空间的分配与回收：由操作系统负责内存空间的分配和管理，记录内存的空闲时间、内存的分配情况，并回收已结束进程所占用的内存空间。
    2. 地址转换
    3. 内存空间的扩充
    4. 内存共享
    5. 存储保护

### 1.1 程序的链接与装入
* Multistep Processing of a User Program 
    1. 编译器 compiler 是一个计算机程序（或一组程序），它将用一种计算机语言（源语言）编写的源代码转换为另一种计算机语言（目标语言，通常具有二进制形式，称为目标代码）。
    2. 链接器 linker 或链接编辑器 linkage editor 是一种程序，它接受编译器生成的一个或多个对象，并将它们组合成一个可执行程序。
    3. 加载器 loader 将.exe文件加载到内存中以供执行。

在编译-链接-装入的过程中会涉及一些地址的转换，大部分是相对的地址（有一些名称来表示）。

* 编译-链接-装入
    1. 编译：从高级语言到目标模块的过程(实际是预处理、编译、汇编三个阶段的统称)，由编译程序将用户源代码编译成若干目标模块     
        本质是一些机器可以“看懂”的0/1指令和数据文件
    2. 链接：把编译后的目标模块与所需库函数链接在一起形成一个完整的装入模块       
        静态链接、装入时动态链接、运行时动态链接
    3. 装入：将虚拟地址映射为内存实际的物理地址，将装入模块装入内存运行     
        绝对装入、静态重定位(可重定位装入)、动态重定位(动态运行时装入)

* 不同的装入方式（不同地址）：
    1. Symbolic Address:源程序中的地址通常是象征性的（比如变量count）。
    2. Relocatable Addresses:编译器通常将这些符号地址绑定到可重定位的地址（例如“从这个模块开始的14个字节”）。
    3. Absolute Addresses:链接器或加载器将可重定位地址绑定到绝对地址（如74014）。绝对装入方式只适用于单道程序环境。在编译时，若知道程序将放到内存的哪个位置，则编译程序将产生绝对地址的目标代码。

* 在不同时刻进行物理地址绑定：
    1. Compile time：如果事先知道内存位置，则可以生成绝对代码；
        * 绝对代码：这段代码被编译成在一个在特定的地址工作的代码，并且只在加载到那个特定的地址时才工作。分支和跳转指令都包含一个固定的精确（绝对）地址。
    2. Load time：如果编译时内存位置未知，则必须生成可重新定位的代码。缺点：一旦确定，地址不可移动
        * 可重定位代码可以加载到内存中的任何位置，但通常在可执行之前即在加载时已经被重定位或修复。
    3. Execution time：如果进程在执行过程中可以从一个内存段移动到另一个内存段，则绑定延迟到运行时。需要硬件支持地址映射（例如，基数寄存器和限制寄存器）。实际中一般采用这种方式（windows等）

* Dynamic Loading：
    1. 例程在调用之前不加载；
    2. 更好的内存空间利用率；不加载未使用的例程
    3. 当需要大量代码来处理不经常发生的情况时非常有用
    4. 不需要通过程序设计实现操作系统的特殊支持

* Dynamic Linking：
    1. 链接延迟到执行时间
        1. 一小段代码stub：用于定位适当的内存驻留库例程
        2. Stub用例程的地址替换自己，并执行该例程
    2. 操作系统需要检查例程是否在进程的内存地址中
    3. 动态链接对库特别有用
        1. 节省主存空间
        2. 减少exe映像文件大小
        3. 重新链接不需要的新库
    4. 系统也称为共享库

!!! warning "Logical vs. Physical Address Space"
    * 逻辑地址：由CPU生成；也称为虚拟地址。
    * 物理地址：存储单元看到的地址。
    * 在编译时和加载时地址绑定方案中，逻辑地址和物理地址是相同的；因为代码里面存放的已经是物理地址了，所以即使CPU看到的是逻辑地址，但此时逻辑地址已经是物理地址了。
    * 在执行时地址绑定方案中，逻辑（虚拟）地址与物理地址不同。因为在执行时绑定，那么在执行之前存的是可重定位地址（是一个和物理地址不一样的逻辑地址），CPU看到的就是这个可重定位地址。

### 1.2 内存保护
内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响，内存保护可采取两种方法：Base and Limit Registers 以及上下限寄存器。

* 上下限寄存器：存放用户进程在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
* Base Registers （重定位寄存器/基地址寄存器）and Limit Registers（限长寄存器/界地址寄存器）：          
    ![](./img/57.png)       
    重定位寄存器中存放的是进程的起始物理地址，界地址寄存器中存放的是进程的最大逻辑地址。内存管理部件将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如下图所示：        
![](./img/59.png){width="450"}      




* Memory-Management Unit (MMU)：实现地址计算
    1. 将虚拟地址映射到物理地址的硬件设备
    2. 在MMU方案中，重定位寄存器中的值在发送到内存时被添加到用户进程生成的每个地址中
    3. 用户程序处理逻辑地址，永远不会看到真正的物理地址

* 一个简单的MMU：       
![](./img/58.png){width="350"}   
图中只是做了一个简单的加法操作，那么为什么要通过硬件实现？  
因为地址转换出现频率高，硬件快速，计算时间可以忽略不计。

### 1.3 连续分配管理方式
连续分配方式是指为一个用户程序分配一个连续的内存空间，譬如某用户需要 100MB 的内存空间，连续分配方式就在内存空间中为用户分配一块连续的 100MB 空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。    

* Contiguous Allocation(连续分配)：
    1. 主存通常分为两个分区：
        1. 常驻操作系统，通常保存在低内存中，带有中断向量
        2. 用户进程保存在高内存中，用于保护用户进程不受其他进程的影响，避免操作系统代码和数据发生变化；
    2. 重定位寄存器用于保护用户进程之间的相互影响，以及防止操作系统代码和数据的变化：
        1. 重定位寄存器(relocation register)包含最小物理地址的值
        2. 限制寄存器(limit register)包含一个逻辑地址范围：每个逻辑地址必须小于限制寄存器

* Single Continuous Allocation：单一连续分配
    1. 内存分为系统区和用户区，用户区每次只调入一道程序运行
        1. 一次只放一道程序，无并发

>Multiple-partition allocation (多分区分配)中包括：     
    1. Fixed Partitioning(固定分区)     
    2. Dynamic Partitions(动态分区)或 Variable Partitiom(可变分区)      

* Fixed Partitioning：固定分区分配：是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的分区，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区。

    ![](./img/61.png){width="150"}

* Dynamic Partitions：动态分区分配
    1. Hole：可用内存块；
    2. 当一个进程到达时，它从一个足够大的洞中分配内存。
    3. 操作系统维护以下信息：
        1. 分配的分区
        2. 空闲分区（洞）

    ![](./img/60.png){width="450"}

    动态分区在开始时是很好的，但是随着时间的推移，内存中产生越来越多的小内存块，内存的利用率也随之降低。这些小内存块被称为外部碎片，它存在于所有分区的外部，与固定分区中的内部碎片正好相对。外部碎片可通过紧凑技术来客服，即操作系统不时地对进程进行移动和整理。但是，这需要动态重定位寄存器的支持，且相对费时。紧凑过程实际上类似于Windows系统中地磁盘碎片整理程序，只不过后者是对外存空间地紧凑。

* 基于顺序搜索的分配方式：
    1. First-fit: 找第一个能满足大小的空闲分区
    2. Next Fit：从上次查找结束的位置考试继续查找第一个能满足大小的空闲分区
    3. Best-fit: 空闲分区按容量递增的次序派李娥。每次分配内存时，顺序查找到第一个能满足大小的空闲分区，即最小的空闲分区，分配给作业。      
        * 最佳适应算法虽然称为最佳，能更多地留下大空闲分区，但性能通常很差，因为每次分配会留下越来越多很小地难以利用地内存块，进而产生最多的外部碎片。
    4. Worst-fit: 空闲分区按容量递减的次序排列。每次分配内存时，顺序查找到第一个能满足要求的空闲分区，即最大的空闲分区，从中分割一部分空间给作业。
        * 不容易产生碎片，但是把最大的空闲分区划分开，会很快导致没有大空闲分区可用，因此性能页比较差。

* 基于索引搜索的分配算法：
    1. 快速适应算法：也称分类搜索算法，将空闲分区按客量大小进行分类，设置素引表项，每一个空闲分区类型对应一项，挂成链(把原来一根变成多根)
        * 根据进程长度，从素引表项中找到能容纳他的最小空闲区链表；从链表中取下第一块进行分配。
    2. 伙伴系统：每个空闲分区大小必须是2的n次幂字节；对进程占用空间n计算一个i值使得2i>n，从剩余空闲分区找最适合的;若无则将分区逐层拆分;释放时则逐层合并
        * 初始内存空间为1024K，有一个进程请求150K空间。
    3. 哈希算法：根据空闲分区链表的分布规律，建立哈希函数，构建一张以空闲分区大小为关键字的哈希表，根据所需空间大小通过计算得到哈希表的位置。
